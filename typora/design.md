# 1、设计原则（七种）

### 1.1、开闭原则（OCP）

概念：当应用的需求改变时，在不修改源码的前提下，可以扩展模块的功能，使其满足新的需求；
作用：提高代码可复用性、提高软件可维护性；
实现：抽象约束、封装变化，即通过接口或抽象类来定义一个相对稳定的抽象层，而将相同的可变因素封装在相同的具体实现中；

### 1.2、里氏替换原则（LSP）

概念：继承必须确保超类所拥有的性质在子类中仍然成立；
作用：是实现开闭原则的重要方式之一、克服了继承中重写父类造成的可复用性变差的缺点、加强程序的健壮性；
实现：子类可以扩展父类的功能，但不能改变父类原有的功能（尽量不用重写父类的方法）；

### 1.3、依赖倒置原则（DIP）

概念：高层模块不应该依赖底层模块，两者都应该依赖其抽象，抽象不应该依赖细节，细节应该依赖抽象；
作用：降低类间耦合性；
实现：目的是通过要面向接口的编程来降低类间的耦合性，是实现开闭原则的重要途径之一；

### 1.4、单一职责原则（SRP）

概念：一个类应该有且仅有一个引起他变化的原因，否则类应该被拆分；
作用：降低类复杂度、提高类可读性；
实现：重构。。。；

### 1.5、接口隔离原则（ISP）

概念：一个类对另一个类的依赖应该建立在最小的接口上；
作用：提高系统内聚性、提高系统稳定性、减少代码冗余；
实现：拆分庞大的接口；

### 1.6、迪米特法则（LOD、LKP）

概念：如果两个实体无需直接通信，那么久不应当发生直接的相互调用，可以通过第三方转发该调用；
作用：降低耦合性、提高复用性及扩展性；
实现：只依赖应该依赖的对象，只暴露应该暴露的方法；

### 1.7、合成复用原则（CRP、CARP）

概念：尽量先考虑使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现；
作用：维持类的封装性、新旧类间的耦合度低、复用的灵活性高；
实现：将已有对象纳入新对象中，作为新对象的成员对象来实现，新对象可以调用已有对象的功能，从而达到复用；

# 2、设计模式（23种）

### 2.1、创建型模式（五种）

##### 2.1.1、单例模式

概念：确保一个类最多只有一个实例，并提供一个全局访问点，可以分为预加载和懒加载两种；
分类：预加载（预先加载，会造成内存的浪费）、懒加载（需要的时候再创建）；

##### 2.1.2、原型模式

概念：通过赋值现有实例来创建新的实例，无需知道相应类的信息，本质就是clone，实现分为浅拷贝及深拷贝；
缺点：定制化拷贝需要修改clone方法，深拷贝实现可能比较麻烦；

##### 2.1.3、工厂方法模式

###### 2.1.3.1、简单工厂模式

概念：定义一个创建对象的类，由这个类来封装实例化的对象；
缺点：拓展对象方法时，必须对工厂类进行修改，违背了开闭原则；

###### 2.1.3.2、工厂方法模式

概念：定义一个创建对象的抽象方法，由子类决定要实例化的类，将对象实例化推迟到了子类，解决了简单工厂模式存在的问题；
缺点：抽象内容只能生产一种抽象产品，类的个数容易过多，增加了复杂度、抽象性等；

###### 2.1.3.3、抽象工厂模式

概念：定义一个接口用于创建相关或有依赖关系的对象族，无需明确指定具体类，解决了工厂方法模式存在的问题；

##### 2.1.4、建造者模式

概念：封装一个复杂对象的构造过程，并允许按步骤构造，通常构建过程中需要多个步骤；
优点：将一个对象分解为各个组件，将对象组件的构造封装起来，可以控制整个对象的生成过程；
缺点：对不同类型的对象需要实现不同的构造器的类，可能会大大增加类的数量；

### 2.2、结构型模式（七种）

##### 2.2.1、代理模式

概念：Proxy，为某对象提供一种代理以控制对该对象的访问，即客户端通过代理间接的访问该对象，从而限制、增强或修改该对象的一些特性；

##### 2.2.2、适配器模式

概念：Adapter，将某个类的接口转换成客户端期望的另一个接口表示，目的是消除由于接口不匹配所造成的的兼容性问题；

##### 2.2.3、桥接模式

概念：将抽象与实现分离，使他们都可以独立的变化，他们是用组合关系代替继承关系来实现的，从而降低了抽象和实现这两个可变维度的耦合度；

##### 2.2.4、装饰器模式

概念：在不改变现有对象机构的情况下，动态的给该对象添加一些功能；
优点：是继承的有力补充（动态扩展，比继承灵活）、完全遵守开闭原则；

##### 2.2.5、外观模式

概念：向客户端提供可以访问系统的接口，并隐藏系统的复杂性；

##### 2.2.6、享元模式

概念：通过共享内存来减少对象的创建，以减少内存占用；

##### 2.2.7、组合模式

别名：整体-部分模式；
概念：是一种将对象组合成树状的层次结构的模式，是用户对单个对象和组合对象具有一致的访问性；

### 2.3、行为型模式（十一种）

##### 2.3.1、模板方法模式

概念：定义一个操作中的算法骨架，而将算法的一些步骤延迟到子类中（子类覆写/实现改方法），使得子类可以不改变该算法结构的情况下重新定义该算法的某些特定步骤；

##### 2.3.2、策略模式

概念：定义了一系列的算法，在运行时可以相互替换，且算法的变化不会影响使用算法的客户；

##### 2.3.3、命令模式

概念：将请求封装成一个对象，使发出请求的责任和执行请求的责任分离，两者之间通过命令对象进行沟通；

##### 2.3.4、责任链模式

别名：职责链模式；
概念：为了避免请求发送者与多个请求处理者耦合在一起，将所有请求的处理者通过前一对象记住其下一对象的引用而连成一条链，当有请求发生时，可将请求沿着这条链传递，直到有对象处理他为止；

##### 2.3.5、状态模式

概念：对象的行为基于其状态的改变而改变的；

##### 2.3.6、观察者模式

别名：发布-订阅模式、模型-视图模式；
概念：多个对象间存在一对多的依赖关系，当一个对象的状态发生改变时，所有依赖他的对象都能得到通知并被自动更新；

##### 2.3.7、中介者模式

别名：调停模式（迪米特法则的典型应用）；
概念：定义一个中介对象来封装一系列对象之间的交互，使原有对象之间的耦合松散，且可以独立的改变他们之间的交互；

##### 2.3.8、迭代器模式

概念：提供一个对象来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示；

##### 2.3.9、访问者模式

概念：将作用于某种数据结构中的各元素的操作分离出来封装成独立的类，使其在不改变数据结构的前提下可以添加作用于这些元素的新操作，为数据结构中的每个元素提供多种访问方式；

##### 2.3.10、备忘录模式

别名：快照模式；
概念：在不破坏封装性的前提下，捕获一个对象的内部类，并在该对象之外保存这个状态，以便以后当需要时能将该对象恢复到原先保存的状态；

##### 2.3.11、解释器模式

概念：给分析对象定义一个语言，并定义该语言的文法表示，再设计一个解析器来解释语言中的局子；

### 2.4、前端常见模式

##### 2.4.1、单例模式

例子：window对象等；
设计：通过闭包实现某个固定值、全局缓存等；

##### 2.4.2、工厂模式

例子：React.Component等；
设计：prototype；

##### 2.4.3、代理模式

例子：Proxy；
设计：Object.defineProperty；

##### 2.4.4、观察者模式

例子：订阅-监听事件等；
设计：自定义事件、事件总线；

##### 2.4.5、策略模式

设计：事件的兼容性处理；

##### 2.4.6、适配器模式