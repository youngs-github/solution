# 1、语法基础

### 1.1、编译

##### 1.1.1、编译阶段

1、分词/词法解析：将字符串分割为有意义的代码块（词法单元）；
2、解析/语法分析：将词法单元转换成抽象语法树（ast）；

##### 1.1.2、编译特点

1、语法分析及生产阶段优化：去除冗余元素，提高执行效率；
2、编译过程优化：如JIT及延迟编译、重编译等；

### 1.2、作用域链

##### 1.2.1、VO

##### 1.2.2、AO

##### 1.2.3、scope

函数的作用域链由定义位置决定，全局函数上级作用域即全局作用域，局部函数上级作用域即外层函数作用域；

##### 1.2.4、闭包

通过高阶函数手段返回对外部函数中变量引用的函数，就称为闭包（必须形成对外部函数变量的引用）；

### 1.3、浮点数

##### 1.3.1、表示

1、符号位：S，长度为1，0表示正数，1表示负数；
2、指数位：E，长度为11，基准数-1023；
3、尾数位：M，长度为52，超出时自动进一舍零，缺少时自动补零，二进制整数存储时均省略整数部分1，故该位有53位；
4、表达式：V=（-1）^S * 2 ^ （E - 1023） * （M + 1）；

##### 1.3.2、精度处理

1、toFixed：先将数字取精度后，再有parseFloat转成数字；
2、转成整数：先乘整数变成整数，进行计算后再取小数；
3、字符串处理：利用字符串运算；

### 1.4、类型转换

##### 1.4.1、==

1、类型相同：使用===严格比较；
2、null==undefined：返回true；
3、string==number：将string转为number进行比较；
4、存在boolean：将其他转为number再比较；
5、存在object：通过ToPrimitive转为基础类型再比较；
6、返回false（一般就是null==1、null==true、null==""、null=symbol等）；

##### 1.4.2、+、-

1、通过ToPrimitive方法获取原始类型（valueOf、toString），非原始类型则返回TypeError；
2、存在string类型，则转为string类型进行求值（ToString）；
3、按照number类型求值（ToNumber）；

##### 1.4.3、ToString

1、undefined、null转为普通字符串；
2、boolean、number、string转为普通字符串；
3、object通过ToPrimitive方法获取原始类型，再转为普通字符串；

##### 1.4.4、ToNumber

1、undefined：NaN;
2、null：0；
3、boolean：true=1、false=0；
4、string：能解析就解析，不能就NaN；
5、object：通过ToPrimitive方法获取原始类型再解析；

### 1.5、var、let、const

1、没有变量提升：var存在提升（创建、初始化），let/const仅创建提升（暂时性死区，不允许使用），function也存在提升（创建、初始化、赋值）；
2、分配内存地址：var会在栈区预分配内存地址（执行时再存储对应变量或者变量地址），let/const不会预分配内存地址（且会检测是否已经存在，存在则报错）；

### 1.6、数据存储

##### 1.6.1、内存空间

1、代码空间：存储执行代码；
2、栈空间：存储原始类型（null、undefined、number、boolean、string、symbol、bigint），其中（typeof null === object 是个bug，为了兼容老代码，故没有修复，其实可以考虑利用严格模式来处理）；
3、堆空间：存储引用类型（object，都是key-value形式）；

##### 1.6.2、闭包存储

1、闭包存储在堆区（closure），编译过程中扫描函数的内部函数（多个闭包方法，执行某个未引用变量的方法时，依然会存在闭包closure对象，因为预扫描是必不可少的）；
2、产生闭包的核心：扫描内部函数、将内部函数引用的外部变量保存到堆中；
3、几乎所有方法都是闭包，除了浏览器（v8等）自带方法，console.dir方法可以打印出方法的作用域链（Scopes）；

##### 1.6.3、问题

1、数据是否可以全部存储在栈空间：不可以，js使用栈来维护上下文的状态，如果栈空间变大的话，会影响上下文切换效率，进而影响到整个程序的效率；

### 1.7、垃圾回收

##### 1.7.1、回收策略

1、手动回收：c、c++；
2、垃圾回收器回收：java、js、py等；

##### 1.7.2、栈内存回收

1、调用栈：ESP指针（记录当前指向状态的指针），函数执行完毕后下移ESP指针，原先ESP指针位置的调用栈不会再使用（后续直接覆盖）；

##### 1.7.3、堆内存回收

1、代际假说：大部分对象在内存中存在时间很短（很快就变的不可访问）、不死的对象会活的更久，适用于很多语言（js、java、py等）；
2、分代回收：新生代（副回收器）、老生代（主回收器）；
3、回收步骤：标记对象（活动对象、非活动对象）、回收对象（清理内存）、内存整理（消除内存碎片）；

##### 1.7.4、副回收器

1、新生代使用Scavenge算法来处理（v8使用并行策略，新开多个线程进行垃圾标记清理，最后同步更新，防止地址变化）；
2、采用复制的方式将堆内存一分为二，该算法是典型的空间换时间算法，只能使用堆内存的一半，但是非常适合新生代这种对象生命周期较短的情况（回收之后，两边角色转换，From空间变成To空间，To空间变成From空间）；
3、对象晋升：新生代对象移动到老生代中的过程称为晋升，From空间的存活对象在复制到To空间之前需要进行检查，对象晋升的条件主要有两个，一个是对象是否经历过Scavenge回收（两次垃圾回收），另一个是To空间的内存占用比超过限制(如果To空间使用量已经超过25%，则直接晋升)；
4、全停顿：stop the world，新生代内存较小，即便使用全停顿影响也不大；

##### 1.7.5、主回收器

1、老生代使用标记-清除算法来处理；
2、标记清除：在标记阶段遍历堆中所有对象，且只标记活着的对象，在随后的清除阶段中，只清除没有被标记的对象（死亡对象），但是在回收后，内存空间会出现不连续的状态（**内存碎片**），所以需要标记整理算法；
3、标记整理：在整理的过程中，将活着的对象往一端移动，移动完成之后，直接清理掉边界外的内存区域，但是需要移动对象，所以执行速度较慢，因此V8主要使用标记清除算法，在空间不足以对晋升对象进行分配时才使用标记整理算法；
4、全停顿：stop the world，老生代内存较大，使用全停顿影响很大，故而产生增量标记、延迟清理、增量整理等算法；
5、增量标记：把完整的垃圾回收任务拆分成很大小任务，垃圾回收与应用逻辑交替执行，提升用户体验；
6、并发标记：多个线程同时在进行标记、整理工作；

##### 1.7.6、三色标记法

作用：在增量回收中，用于实现垃圾回收器的暂停和恢复执行；
1、黑色：被GC Root引用，并且子节点已经完成标记；
2、灰色：被GC Root引用，但子节点还有未被标记部分，表明当前正在处理这个节点；
3、白色：节点尚未被访问到，如果在本轮遍历结束时还是白色，就表明是未引用数据，会被回收；

### 1.8、V8

##### 1.8.1、编译/解释

1、编译型语言：c/c++、go等（源代码（词法分析、语法分析）=> ast（词义分析）=> 中间代码（代码优化）=> 二进制文件 => 执行）；
2、解释型语言：js、py等（源代码（词法分析、语法分析）=> ast（词义分析）=> 字节码（解释执行）=> 执行）；

##### 1.8.2、执行过程

1、生成AST：通过编译器（Compiler）处理，词法分析（分词，遍历字符串获取词法内容，如关键字、变量标识符、操作符、赋值符等）、语法分析（解析，按照规则，将分词结果转换为AST，如果这一步错误，则抛出**语法错误**）；
2、生成字节码：通过解释器（Ignition）处理，根据AST生成字节码（早起没有字节码，直接转为机器码，但机器码占用存储空间太大）；
3、执行字节码：通过解释器（Ignition）+编译器（TurboFan）处理，非热点代码会逐条解释执行，如果是热点代码（一段代码被多次执行），会使用编译器将字节码转为机器码（一次编译，多次运行），故随着时间进行执行效率会越来越高，这种混合技术称为即时编译（JIT，java、py等虚拟机也是这样设计）；

##### 1.8.3、性能优化

1、提升单次脚本的执行速度，避免长时间阻塞主线程；
2、避免大的内联脚本（同步脚本尽量内联，其他脚本尽量异步）；
3、减少脚本大小，提升下载速度，缩小占用内存；

# 2、相关知识

### 2.1、event loop

1、宏（外部）队列：macrotask queue，包括：DOM操作、用户交互、网络请求、history操作、定时器、script标签、requestAnimationFrame、MessageChannel等；
2、微（内部）队列：microtask queue，包括：Promise、process.nextTick、MutationObserver、Object.observe（已废弃）；
3、调度过程：每次从宏任务队列取出一个任务，执行完毕之后执行微任务队列（全部），执行浏览器渲染任务，循环往复；

### 2.2、继承

1、原型链：将父类实例绑定到子类原型链上；
2、借用构造函数：子类构造函数中借用父类构造函数；
3、组合式：使用1、2两点，并将constructor指向子类；
4、原型式：利用空对象作为媒介，new F()，F的原型链指向被继承对象；
5、寄生式：使用第4点，同时将原型方法、属性挂载到实例上；
6、寄生组合式：使用第4点，create父类原型的子元素，将constructor指向子类，并赋值给子类原型，new 时借用父类构造函数；

### 2.3、模块化发展

1、iife：立即执行函数，单独作用域，避免变量冲突；
2、amd：requireJS，依赖必须提前声明好，后面支持延迟加载；
3、cmd：seaJS，强调延迟加载，支持动态引入依赖文件；
4、commonJS：nodejs，动态引入、浅拷贝、缓存（解决循环依赖，默认空对象）；
5、umd：兼容amd、cmd、commonJS语法；
6、es module：静态依赖，静态只读引用，等运行时再去依赖里面取出实际需要的值；

### 2.4、ES模块

##### 2.4.1、es6

1、let、const；
2、字符串扩展：模板字符串、includes、startsWith、endsWith；
3、解构表达式；
4、函数：参数默认值、箭头函数、对象函数简写；
5、数组：map、reduce；
6、对象：对象属性简写；
7、扩展运算符：多用于数组、类数组、对象；
8、promise；
9、set/map；
10、class语法；
11、generator：yield、for of遍历；
12、模块化；

##### 2.4.2、es7

1、数组：includes；
2、指数：2**3；

##### 2.4.3、es8

1、async、await；
2、Object.entries/values：补充Object.keys；
3、字符串扩展：padStart、padEnd，填充使用，长度+string；
4、SharedArrayBuffer、Atomic；

##### 2.4.4、es9

1、异步迭代：await + for；
2、Promise.finally；
3、rest/spread属性：fn(arg1, arg2, ...args)；
4、正则表达式补充；

##### 2.4.5、es10

1、JSON.stringify优化；
2、flat、flatMap；
3、字符串trimStart、trimEnd；
4、Object.fromEntries；
5、Symbol.prototype.description：symbol的描述信息；

##### 2.4.6、es11

1、基本类型：BigInt；
2、动态导入：import()、import.meta（导入对象元数据，如import.meta.url即为导入内容）；
3、Promise.allSettled；
4、可选链：?.（存在则处理）；
5、空值合并：??（仅当左侧为null或undefined时选择右侧）；
6、导出内容：export * as ns from 'xxx'；

### 2.5、箭头函数

1、this：箭头函数没有自己的this，因此使用call、bind、apply方法无法更改其this指向；
2、arguments：箭头函数不绑定arguments属性，可以使用rest参数；
3、prototype：箭头函数没有prototype，也就没有继承的super；
4、new：箭头函数不能使用new命令，也就没有new.target；
5、generator：箭头函数不能使用yield命令，不能做generator函数；