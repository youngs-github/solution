## 1、创建型模式（五种）

#### 1.1、单例模式

概念：确保一个类最多只有一个实例，并提供一个全局访问点，可以分为预加载和懒加载两种；

###### 1.1.1、预加载

概念：预先加载，会造成内存的浪费；

###### 1.1.2、懒加载

概念：需要的时候再创建；

#### 1.2、原型模式

概念：通过赋值现有实例来创建新的实例，无需知道相应类的信息，本质就是clone，实现分为浅拷贝及深拷贝；
缺点：定制化拷贝需要修改clone方法，深拷贝实现可能比较麻烦；

#### 1.3、工厂方法模式

###### 1.3.1、简单工厂模式

概念：定义一个创建对象的类，由这个类来封装实例化的对象；
缺点：拓展对象方法时，必须对工厂类进行修改，违背了开闭原则；

###### 1.3.2、工厂方法模式

概念：定义一个创建对象的抽象方法，由子类决定要实例化的类，将对象实例化推迟到了子类，解决了简单工厂模式存在的问题；
缺点：抽象内容只能生产一种抽象产品，类的个数容易过多，增加了复杂度、抽象性等；

###### 1.3.3、抽象工厂模式

概念：定义一个接口用于创建相关或有依赖关系的对象族，无需明确指定具体类，解决了工厂方法模式存在的问题；

#### 1.4、建造者模式

概念：封装一个复杂对象的构造过程，并允许按步骤构造，通常构建过程中需要多个步骤；
优点：将一个对象分解为各个组件，将对象组件的构造封装起来，可以控制整个对象的生成过程；
缺点：对不同类型的对象需要实现不同的构造器的类，可能会大大增加类的数量；



## 2、结构型模式（七种）

#### 2.1、代理模式

概念：Proxy，为某对象提供一种代理以控制对该对象的访问，即客户端通过代理间接的访问该对象，从而限制、增强或修改该对象的一些特性；

#### 2.2、适配器模式

概念：Adapter，将某个类的接口转换成客户端期望的另一个接口表示，目的是消除由于接口不匹配所造成的的兼容性问题；

#### 2.3、桥接模式

概念：将抽象与实现分离，使他们都可以独立的变化，他们是用组合关系代替继承关系来实现的，从而降低了抽象和实现这两个可变维度的耦合度；

#### 2.4、装饰器模式

#### 2.5、外观模式

#### 2.6、享元模式

#### 2.7、组合模式



## 3、行为型模式（十一种）

#### 3.1、模板方法模式

#### 3.2、策略模式

#### 3.3、命令模式

#### 3.4、责任链模式

#### 3.5、状态模式

#### 3.6、观察者模式

#### 3.7、中介者模式

#### 3.8、迭代器模式

#### 3.9、访问者模式

#### 3.10、备忘录模式

#### 3.11、解释器模式