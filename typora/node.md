# 1、模块机制

### 1.1、CommonJS规范

### 1.2、Node模块机制

##### 1.2.1、引入步骤

1）路径分析
2）文件定位
3）编译执行

##### 1.2.2、模块分类

1）核心模块：node自身提供的模块，编译进了二进制执行文件，启动时加载进内存，路径分析时优先判断，所以加载速度最快；
2）文件模块：用户编写的模块，运行时加载，经历完整的模块引入步骤，速度慢于核心模块；

##### 1.2.3、加载过程

1）优先从缓存加载：引入过的模块均会进行缓存以减少二次引入开销（二次引入时不需要路径分析、文件定位和编译执行的过程），这是第一优先级，且核心模块的缓存检查优先于文件模块的缓存检查；
2）路径分析和文件定位：
	① 模块标识符分析：
				核心模块(fs、http等，速度最快)、相对路径文件模块（.或..开始）、绝对路径文件模块（/开头）、非路径形式的文件模块（如自定义的module名称，速度最慢 --> 其中，模块路径查找规则为：从当前目录查找node_modules文件夹 -> 父级node_modules文件夹 ... 根目录node_modules文件夹，所以当前文件路径越深，模块查找越耗时）
	② 文件定位：
				文件扩展名分析（默认依次识别.js、.json、.node扩展名，检测过程中使用同步阻塞方式，故.json/.node推荐带上扩展名）、目录分析和包(如果第一步的结果是个目录，则会当成包进行处理，优先查找package.json文件进行提取main模块，失败则会查找index文件名，再次失败则会抛出异常)
3）模块编译：
	注：每一个编译成功的模块都会将其文件路径作为索引缓存在Module.cache对象上；
	① .js文件编译：fs模块读取文件后编译执行，正常js模块会被包装成function(exports, require, module, --filename, --dirname) {\n 代码块 \n}，通过vm原生模块执行，this指向该模块本身；
	② .node文件编译：这是C/C++编写的扩展文件，通过process.dlopen()方法加载最后编译生成的结果，针对不同平台libuv进行封装，实际上，该部分并不需要编译，因为是C/C++文件编译后生成的；
	③ .json文件编译：fs模块读取文件后用JSON.parse()解析返回结果，该部分最简单；
	④ 其他扩展名文件：均当成.js文件进行解析；

### 1.3、核心模块

注：该部分分为C/C++模块（src目录下）、JS模块（lib目录下，该部分也需要经历头尾包装的过程，只是属于核心模块，存储于内存中）

### 1.4、NPM模块

# 2、异步I/O实现

### 2.1、I/O分类

注：操作系统层级：阻塞I/0、非阻塞I/O
		① 阻塞I/O：通过文件描述符实现文件数据读写，等待整个数据获取；
		② 非阻塞I/0：通过文件描述符实现文件数据读写，不等待立即返回，后续通过文件描述符进行轮询进行读取；
轮询技术：
		① read：最原始、性能最低，通过重复调用while (true)检查I/O状态完成读取；
		② select：在read基础上，通过对文件描述符的事件状态进行判断(因为存储大小原因，最多可以同时检查1024个文件描述符)；
		③ poll：改进select方案，采用链表方式避免数组长度限制，且能避免不需要的检查，但是当文件描述符较多时性能还是很低；
		④ epoll：linux下效率最高的I/O事件通知机制，利用事件通知、执行回调的方式，红黑树维护事件系统，没有事件时进行休眠；
		⑤ kquene：与epoll类似，只存在于FreeBSD系统中；

### 2.2、异步I/O

原生：目前仅有linux系统实现（AIO），且仅支持内核方法；
模拟：glibc、libev、libeio、libuv（u/linux使用自定义线程池，windows使用IOCP）、IOCP(windows)；

### 2.3、Node的异步I/O

##### 2.3.1、事件循环

Tick：类似while(true)的循环流程，通过观察者模式判断是否有事件需要处理，浏览器采用类似的机制；
定时器：setTimeout、setInterval，并非精确时间、可能被阻塞、定时器观察者内部使用红黑树存储（O(lg(n))），因此稍微有点浪费性能（对比process.nextTick方式）
定时器：setImmediate，回调保存于链表中，在check阶段执行，每轮循环只执行一个任务；
nextTick：微任务，回调保存于数组中，在idle阶段执行，每轮循环会执行完所有任务；

##### 2.3.2、第一阶段

执行过程：fs.open、src/node_file.cc（open）、平台判断（src/unix/fs.c或src/win/fs.c的uv_fs_open方法）、等待线程池执行，js执行第一阶段结束(请求对象是异步I/O过程中的重要产物，包含整个调用的所有状态)；

##### 2.3.3、第二阶段

执行过程：等待线程池执行、执行请求对象的I/O操作、将结果存储在请求对象上、通知异步I/O已完成(观察者调用执行)、归还线程；

# 3、内存控制

### 3.1、V8的内存机制

##### 3.1.1、V8的内存限制

默认情况下，64位系统约为1.4GB，32位系统约为0.7GB，可以在启动时传递--max-old-space-size（单位：MB）或--max-new-space-size（单位：KB）来调整内存限制，启动之后无法改变，这属于V8与生俱来的特性(浏览器端)；

##### 3.1.2、垃圾回收机制

1、主要基于分代回收机制：老生代、新生代（没有哪一种算法能够胜任所有的场景）；
2、老生代默认内存限制为：64位系统1400MB，32位系统700MB，可以通过--max-old-space-size控制；
3、新生代默认内存限制为：64位系统64MB，32位系统32MB，可以通过--max-new-space-size控制；
4、V8堆内存的最大空间为：4 * reserved_semispace_size + max_old_generation_size，即老生代 + 两倍新生代；
5、Scavenge算法：新生代中的对象主要通过该算法进行垃圾回收，主要采用Cheney算法实现：采用复制的方式将堆内存一分为二，每一部分空间称为semispace，该算法是典型的空间换时间算法，只能使用堆内存的一半，但是非常适合新生代这种对象生命周期较短的情况（回收之后，两边角色转换，From空间变成To空间，To空间变成From空间）；
6、晋升：新生代对象移动到老生代中的过程称为晋升，From空间的存活对象在复制到To空间之前需要进行检查，对象晋升的条件主要有两个，一个是对象是否经历过Scavenge回收（一次回收即可，闭包的变量存储问题），另一个是To空间的内存占用比超过限制(如果To空间使用量已经超过25%，则直接晋升)；
7、Mark Sweep/Compact算法：标记清除/整理算法，老生代中的对象主要通过该算法进行垃圾回收；
8、标记清除算法：在标记阶段遍历堆中所有对象，且只标记活着的对象，在随后的清除阶段中，只清除没有被标记的对象（死亡对象），但是在回收后，内存空间会出现不连续的状态（**内存碎片**），所以需要标记整理算法；
9、标记整理算法：在整理的过程中，将活着的对象往一端移动，移动完成之后，直接清理掉边界外的内存区域，但是需要移动对象，所以执行速度较慢，因此V8主要使用标记清除算法，在空间不足以对晋升对象进行分配时才使用标记整理算法；
10、Incremental Marking：增量标记，因为垃圾回收算法均需要**全停顿**（**stop the world**），所以V8从标记阶段即改为增量标记(一点点标记)，垃圾回收与应用逻辑交替执行直到标记阶段完成（改进后，最大全停顿时间减少到原来的1/6左右）；
11、Lazy Sweeping：延迟清理；
12、Incremental Compaction：增量整理；

##### 3.1.3、三色标记法

作用：在增量回收中，用于实现垃圾回收器的暂停和恢复执行；
1、黑色：被GC Root引用，并且子节点已经完成标记；
2、灰色：被GC Root引用，但子节点还有未被标记部分，表明当前正在处理这个节点；
3、白色：节点尚未被访问到，如果在本轮遍历结束时还是白色，就表明是未引用数据，会被回收；

##### 3.1.4、垃圾回收日志

1、--trace_gc：进行垃圾回收时，将会从标准输出中打印垃圾回收日志信息；
2、--prof：生成自带的prof日志文件，使用--prof-process转成统计文件进行查看；

### 3.2、V8的内存指标

1、process.memoryUsage：内存使用量，包含rss、heapTotal、heapUsed；
2、os.totalmem：系统总内存；
3、os.freemem：系统闲置内存；
4、堆外内存：node中的内存使用并非都是通过V8进行分配，例如Buffer对象，其内存不受V8内存限制（即不会有堆内存大小限制，该部分不同于浏览器）；

### 3.3、内存泄漏

##### 3.3.1、缓存

慎将内存当做缓存；
1、持久缓存：对象常驻老生代，而垃圾回收器会对其做无用功；
2、键值对缓存：谨慎使用，避免长久未回收现象，例如**限制键值对数量**（类似LRU算法，小型应用场景）、**模块设计机制**（模块均是闭包，常驻老生代，尽量避免模块级持久变量的导出使用）；
3、进程外缓存：Redis等；

##### 3.3.2、队列堆积

当队列的消费速度低于生产速度时，容易造成数据堆积（例如日志收集系统），如果生产速度陡增或者消费速度降低，内存泄漏还是可能出现的；
1、监控队列长度：通知研发、超时处理、拒绝模式等；
2、消息队列：kafka、rocket等；

##### 3.3.3、作用域未释放

闭包；

##### 3.3.4、内存泄漏排查

1、v8-profiler：抓取V8堆快照和cpu进行分析（不维护）；
2、node-heapdump：抓取V8堆快照，用于事后分析；
3、node-mtrace：使用GCC的mtrace工具来分析堆的使用；
4、node-memwatch：；

# 未完成！

# 4、Buffer模块

Buffer属于堆外内存，由C++直接管理，size在定义时固定不能随意更改，对js部分提供接口调用，启动时挂在于global对象上，无需require；

### 4.1、Buffer对象

1、对象结构：Buffer对象类似数组，元素为16进制的两位数（0-255的数值），不符合时会通过加减使其符合；
2、内存分配：Buffer采用slab分配机制（full：满，partial：部分，empty：未分配），默认8KB（poolSize：8192），分配小对象时会从剩余空间进行分配，分配大对象时会直接分配一个大单元；

### 4.2、Buffer转换

1、默认支持：ascii、utf-8（默认使用）、utf-16、base64、hex、binary；
2、toString方法：encoding（utf-8）、start、end；

### 4.3、Buffer拼接

1、toString方法：string类型 + buffer类型时，默认调用toString方法进行转换；
2、utf-8类型：字符长度不一致，如果限制highWaterMark，可能会读取乱码，也可以设置较大解决乱码（局限性大）；
3、setEncoding方法：将data事件中传递的buffer对象替换成string对象，即为编码后的字符串，内部进行识别，不满的放到下次（不能从根本上解决问题）；
4、concat方法：类似Array.concat方法，拼接成一个大Buffer对象；

### 4.4、Buffer与性能

tcp流及文件流是八位字节流；
1、tcp传输：做web时，将字符串转为buffer很有必要，可以节省很大转换时间；
2、文件读取：利用stream进行文件读取时，buffer的size对读写速度的影响很大（buffer过小时，需要频繁调用底层I/O，过大时初始分配较为耗时），可以通过highWaterMark的大小进行控制（通常越大读取越快，可综合考虑机器内存）；

# 5、网络编程

node是一个面向网络而生的平台，具有事件驱动、无阻塞、单线程等特性；

### 5.1、TCP服务器

TCP面向连接（可靠的），基于流传输（无消息保护边界），采用消息确认机制（安全的）；
1、Nagle算法：作用（避免发送大量的小包，防止小包泛滥于网络），策略（只有上一个分组得到确认才会发送下一个分组，收集多个小分组在一个确认到来时一起发送），理想情况下，一个tcp连接每次只能有一个小包存在；
2、TCP粘包（应用层问题，TCP无包概念）：原因（发送方：启用Nagle算法、接收方：tcp将收到的数据包缓存到接收缓存里，应用程序主动从缓存读取，如果读取速度小于接收速度，就有可能读取到多个首尾相接粘在一起的包），处理（关闭Nagle算法、格式化数据：每条数据添加固定的开始结束符号、消息长度：规定前几位为消息长度）
3、单工、半双工、全双工；

### 5.2、UDP服务器

UDP无连接，面向消息传输（有消息保护边界）；

### 5.3、HTTP服务器

HTTP基于请求响应式，无状态及会话特点；

### 5.4、WebSocket服务器

Node与WebSocket配置堪称完美：基于事件模型、基于TCP长连接；
1、协议升级：Connection（upgrade）、Upgrade（websocket）；
2、安全头认证：Sec-WebSocket-Key、Sec-WebSocket-Accept、Sec-WebSocket-Protocol；

### 5.5、网络服务与安全

1、SSL/TLS协议：基于传输层（基于TCP连接的加密），使用证书加密；
2、HTTPS协议：基于HTTP+SSL/TLS；

# 6、Web应用

### 6.1、基础功能

1、请求方法的判断；
2、url解析（路径、查询字符串）；
3、cookie解析；
4、session解析；
5、表单数据的解析；
6、文件上传解析；
7、等；

### 6.2、路由解析

1、文件路径模式；
2、mvc模式；
3、restful模式；

### 6.3、中间件

洋葱模型中间件；
1、处理流程：由外到内，由内到外；
2、异常处理；
3、性能处理（使用高效的方法、缓存部分内容、避免不必要的计算）；

### 6.4、模板引擎

1、模板编译（缓存文件模板、缓存编译后的函数）；
2、模板安全（XSS漏洞），使用转义进行解决（&、<、>、"、'，可能存在兼容性问题）；
3、Bigpipe；

# 7、多进程架构

### 7.1、Node多进程架构

服务模型的变迁：同步模型、多进程模型、多线程模型、事件驱动模型；

##### 7.1.1、创建子进程

1、spawn：无回调、任意进程类型、命令式、不可设置超时；
2、exec：有回调、任意进程类型、命令式、可设置超时；
3、execFile：有回调、任意进程类型、可执行文件式、可设置超时；
4、fork：无回调、Node进程类型、js文件式、不可设置超时，用的最多（Node进程类型）；
注：后三种均是spawn的延伸应用；

##### 7.1.2、进程间通信

IPC：inter-process communication，进程间通信；
实现方式：命名管道、匿名管道、socket、信号量、共享内存、消息队列、Domain Socket等，windows下由命名管道实现，*nix下由Unix Domain Socket（UDS）实现；
创建过程：父进程先创建IPC通道并进行监听、创建子进程（读取父进程提供的环境变量Node_Channel_FD：IPC通道的文件描述符）；
注：只有启动的子进程是Node进程时，子进程才会根据环境变量去连接IPC通道；

### 7.2、Node Cluster

##### 7.2.1、集群模式

1、集群模式通常有两种实现方案：
	①  1个Node实例开启多个端口，通过反向代理向各个端口进行转发；
	②  1个Node实例开启多个进程监听同一端口，通过负载均衡分配请求（Master进程进行请求分配）；
2、Node Cluster采用第二种方案；

##### 7.2.2、监听同一端口

1、master进程监听端口，而非子进程进行监听，父子进程建立好IPC通信后，父进程发送Socket到子进程实现端口共享，之后请求从master进程向子进程分配；
2、负载均衡算法：除windows外默认是RR（Round-Robin：实现简单且易用，但如果出现某个请求占用较长时间，就会导致负载不太会均衡）；

### 7.3、集群稳定

1、异常则退出；
2、退出则重启；
3、重新需限量；
4、其他库：PM2等；

# 8、主流框架

### 8.1、express 、koa

##### 8.1.1、相同点：

1、均是优秀的web框架；
2、均是按照洋葱模型理念进行设计；
3、均是支持中间件的可扩展框架；

##### 8.1.2 不同点

1、koa是严格遵循洋葱模型理念，express的next方法仅支持同步操作（异步操作时，无法遵循洋葱模型理念）；
2、express异常捕获，要么单独添加callback（较为麻烦），要么添加中间件（错误堆栈丢失，较难排查错误信息）；
3、koa响应是通过body，express响应是通过send、json等实现；

### 8.2、egg、nest

##### 8.2.1、相同点

1、均是优秀的企业级web框架；

##### 8.2.2、不同点

1、egg基于koa，nest默认基于express（可更改）；
2、egg文档更优秀，更符合mvc模型，约定更标准；
3、nest更符合面向对象理念，本身基于ts，语法较多借鉴angular，类似java的spring；

